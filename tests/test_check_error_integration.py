"""
Integration test to demonstrate _check_error function scenarios in practice.

This demonstrates the three branches with realistic examples from actual BELLHOP operations.
"""

import pytest
import tempfile
import os
import subprocess
import sys
from pathlib import Path
from bellhop.bellhop import _Bellhop


def test_check_error_integration_with_actual_bellhop():
    """
    Integration test that exercises _check_error with actual BELLHOP execution scenarios.
    This test demonstrates all branches of _check_error in realistic conditions.
    """
    bellhop = _Bellhop()
    
    # Test 1: Missing .prt file (FileNotFoundError branch)
    temp_dir = tempfile.mkdtemp()
    missing_base = os.path.join(temp_dir, "missing_file")
    
    # This should hit the FileNotFoundError branch
    result = bellhop._check_error(missing_base)
    assert result is None, "Should return None when .prt file doesn't exist"
    
    # Test 2: Create a realistic .prt file that would be generated by a successful run
    success_base = os.path.join(temp_dir, "success_run")
    success_prt = success_base + ".prt"
    
    # Create a .prt file that mimics successful BELLHOP output
    with open(success_prt, 'w') as f:
        f.write("BELLHOP-\n")
        f.write("Acoustic propagation model\n") 
        f.write("Copyright (C) 2009 Michael B. Porter\n")
        f.write("\n")
        f.write("Reading source angles\n")
        f.write("Reading receiver positions\n")
        f.write("Computing ray traces ...\n")
        f.write("\n")
        f.write("Number of rays = 501\n")
        f.write("Frequency =  50.00 Hz\n")
        f.write("\n")
        f.write("CPU time =  0.02 seconds\n")
    
    # This should return None (no error found)
    result = bellhop._check_error(success_base)
    assert result is None, "Should return None when no fatal error in .prt file"
    
    # Test 3: Create a .prt file with fatal error (like what ERROUT would generate)
    error_base = os.path.join(temp_dir, "error_run")
    error_prt = error_base + ".prt"
    
    # Create a .prt file that mimics BELLHOP fatal error output
    # (based on FatalError.f90 ERROUT subroutine)
    with open(error_prt, 'w') as f:
        f.write("BELLHOP-\n")
        f.write("Acoustic propagation model\n")
        f.write("Copyright (C) 2009 Michael B. Porter\n")
        f.write("\n")
        f.write("Reading source angles\n")
        f.write("Reading receiver positions\n")
        f.write("\n")
        f.write("*** FATAL ERROR ***\n")  # This triggers the error detection
        f.write("Generated by program or subroutine: BELLHOP\n")
        f.write("Invalid input parameter in environment file\n")
        f.write("Check your sound speed profile specification\n")
        f.write("\n")
    
    # This should return the full error message with [BELLHOP] prefixes
    result = bellhop._check_error(error_base)
    assert result is not None, "Should return error message when fatal error found"
    assert result.startswith('\n[BELLHOP] *** FATAL ERROR ***'), "Should start with fatal error line"
    assert '[BELLHOP] Generated by program or subroutine: BELLHOP' in result
    assert '[BELLHOP] Invalid input parameter in environment file' in result
    assert '[BELLHOP] Check your sound speed profile specification' in result
    
    # Clean up
    import shutil
    shutil.rmtree(temp_dir, ignore_errors=True)


def test_error_message_formatting():
    """Test that error messages are properly formatted as they would appear to users."""
    bellhop = _Bellhop()
    temp_dir = tempfile.mkdtemp()
    
    test_base = os.path.join(temp_dir, "format_test")
    test_prt = test_base + ".prt"
    
    # Create a realistic error scenario
    with open(test_prt, 'w') as f:
        f.write("BELLHOP- Underwater Acoustic Program\n")
        f.write("Processing environment file...\n")
        f.write("\n")
        f.write("*** FATAL ERROR ***\n")
        f.write("Generated by program or subroutine: ReadEnvironmentBell\n")
        f.write("Sound speed must be positive\n")
        f.write("Found c =    0.0000 at depth    10.00\n")
        f.write("Program terminated\n")
    
    result = bellhop._check_error(test_base)
    
    # Verify the format matches what users would expect
    expected_lines = [
        '\n[BELLHOP] *** FATAL ERROR ***',
        '[BELLHOP] Generated by program or subroutine: ReadEnvironmentBell',
        '[BELLHOP] Sound speed must be positive',
        '[BELLHOP] Found c =    0.0000 at depth    10.00',
        '[BELLHOP] Program terminated'
    ]
    
    for expected in expected_lines:
        assert expected in result, f"Expected line not found: {expected}"
    
    # Should not include lines before the fatal error
    assert '[BELLHOP] BELLHOP- Underwater Acoustic Program' not in result
    assert '[BELLHOP] Processing environment file...' not in result
    
    # Clean up
    import shutil
    shutil.rmtree(temp_dir, ignore_errors=True)


if __name__ == "__main__":
    # Allow running this test file directly for demonstration
    test_check_error_integration_with_actual_bellhop()
    test_error_message_formatting()
    print("All integration tests passed!")